# 物理内存管理
实验一过后大家做出来了一个可以启动的系统，实验二主要涉及操作系统的物理内存管理。操作系统为了使用内存，还需高效地管理内存资源。在实验二中大家会了解并且自己动手完成一个简单的物理内存管理系统。

### 几个遇到的问题和解决
1. 在pmm.c::page_init()中, 我们发现, 最后一个for循环中, 将e820获取的非保留的,并且包含在pages数组之后, 到896MB之间所有4KB内存页调用了init_memmap来将他们初始化成free page, 那么问题是, 难道内核代码区也变成了可分配内存区了吗, 这样不会导致内核代码被覆盖吗?

  - 研究pages这个地址的由来可以发现, 它被赋值为外部符号end, 并且4K对齐, 可以发现找遍了所有C代码和汇编代码, 都没有这个全局符号. 最后在链接脚本中可以找到这个符号, 它被定义为kernel文件的大小(最后一个段的下一个段(不存在的)的开始地址), 这样一来, kernel代码就还是保持不可分配的reserved状态, 不会被内存管理器分配出去.


2. 在lab2实验导引中描述的first fit内存分配算法中, 是用双向链表把空闲内存块按照空闲块第一页的首地址的顺序从小到大排列的. 所以我们应该在分配内存和释放内存的时候都要维护这个顺序, 在释放内存的时候, 实验的帮助注释中写了, 需要维护顺序的问题, 也有测释放内存后顺序的维护的测试用例. 但是分配内存的时候, 如果按照示例的写法也会导致顺序被打乱, 原因是在双向连表中删除了原来的Page后, 未将新Page插入到原来的Page位置, 而是直接放到链表头了. 所以在分配时候记下位置可以改正这个问题, 而且没有对应的测试用例.

3. 关于ex1 first fit内存分配算法的实现, 参考答案中, 将所有的Page对象全部加入了双向链表, 并且设置这些Page全部是reserved, 这样做是低效的, 因为如果在内存的地址较高的地方如果存在一块较大可用内存块, 这样, 分配内存的时候就要遍历这些没用的Page才能找到那块大内存块, 降低了效率. 我认为应该在双向链表中只维护每个内存块的第一页的Page对象, 并且用property记录下这块内存块的大小, 这样, 连续内存块的数量就和双向链表内部元素的个数相同了, 把双向链表中元素个数从三万多减少到几个.

### 实验实现细节

1. ex1. 主要实现default_init_memmap, default_alloc_pages, default_free_pages
  - default_init_memmap, 设置一些可用的内存页
  - default_alloc_pages, 分配n页内存, 具体算法是从当前可分配的连续内存块中找到第一块大于等于所需内存的, 分配给用户, 如果该内存块不是正好等于用户所需的大小, 那么, 缩小这块内存块.
  - default_free_pages, 回收内存页重新设置为可分配状态, 如果恰好可以合并, 和前后的内存块合并(可能合并两次), 并且需要注意保持顺序.
2. ex2, ex3.
  - get_pte, 通过虚拟地址返回页表项的地址, 不存在可以选择创建, 需要递增Page的ref. 但是我认为用户级应用程序应该不可用这部分内存, 所以我觉得不应该有PTE_U属性.
  - page_remove_pte, 需要递减一下物理页对应的Page, 如果为0了需要释放物理页.
