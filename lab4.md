# 实验四：内核线程管理

1. 内核线程在ucore中的实现

  - ucore中的内核线程是非抢占的, 必须线程主动返回才会切换到下一个线程
  - 每个内核线程包含独立的执行上下文(context), trapframe和堆栈 但是内存是共享的, 所有内核线程的页表都是使用的boot_pgdir, 段描述符都使用gdt中的内核代码段和内核数据段.

2. 内核线程的启动和切换
    1. do_fork中创建了描述proc的数据结构, 并且把该线程(进程)添加到进程链表中, 并且设置该进程可调度. kernel_thread函数中把进程的入口地址(kernel_thread_entry)存入进程context的eip中, 这样当进程恢复执行的时候就会从这个地址开始运行;
    2. kernel_thread_entry: 该符号在kern/process/entry.S中, 它用ebx传入真正的进程入口地址, 调用该入口函数, 当入口函数返回后, 调用proc_exit结束进程;
    3. cpu_idle中, schedule函数找到下一个可调度的进程, 调用proc_run;
    4. proc_run中, 修改cr0切换页表, 切换堆栈, 这些信息都存在proc_struct结构体中, 最后调用switch_to这个汇编函数
    5. switch_to 这个函数负责保存前一个进程的上下文, 并且设置下一个进程的上下文, 最后压入保存的eip, ret指令(模拟)函数返回, 跳转到了进程入口地址.
    6. 当进程返回, 根据2所述, 会调用proc_exit. 当前这个函数只会停止内核. 这个函数真正的实现应该是设置进程为ZOMBIE状态并且sched使其他进程得到控制权.

3. proc_struct结构体指针的组织
    系统中所有的进程的proc_struct以多种方式连接
      - 哈希表, pid => proc_struct, 这种方式可以快速通过pid来查找进程
      - 双向链表, 可以以创建的顺序便利
      - 每个proc_struct有一个parent指针指向创建者, 这导致所有的进程组织成以init进程为根的树形

4. 第1题: get_pid的实现. last_pid和next_safe两个static变量之间是一个未被使用的pid区间, 每次需要新生成一个pid时, last_pid++, 如果没有将区间长度变为0, 那么就成功获得了一个pid. 否则遍历pid列表, 从last_pid和MAX_PID之间找一个没有呗使用的pid, 并且维护last_pid和next_safe之间都是未被使用的pid. 这样可以是pid唯一. 但是当pid全部使用光了的时候, get_pid会死循环.

5. 第2题: context在switch.S文件的switch_to中被使用, 用来保存和恢复线程的执行上下文, trapframe是用来在线程返回内核(中断,系统调用..)的时候恢复内核执行上下文用的, 如果是用户级线程, 还会发生特权级切换, 会用到trapframe中保存的内核堆栈.

6. 第3题:
    - 如果认为创建了proc_struct就叫"创建", 那么是创建了两个内核进程. 尝试创建多个线程, 只有最后一个创建的线程会被启动, 但是如果在线程函数中调用schedule, 会导致其他线程被启动, 所以现在线程之间不能抢占运行, 只能手动放弃CPU从而让其他线程执行.

    - 保存并且关闭中断的作用:
        1. 防止这段修改current代码重入, 如果之后改成了以时钟中断来出发进程切换的话, 这就相当于加了锁, 禁止其他进程运行
        2. 保存中断状态防止新进程中修改中断使能状态
